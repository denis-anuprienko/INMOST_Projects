#include "inmost.h"

//    !!!!!!! Currently NOT suited for parallel run
//
//
//    The purpose of this code
//    is to compare coupling approaches
//    for density-driven flow,
//    like fully-implicit scheme and sequential approach
//
//
//    The user should provide 2D mesh
//    (preferrably, a .vtk file which can be generated by Gmsh for example)
//    which is built for (0;1)x(0;1)
//
//    The code will then
//    - process mesh,
//    - init tags,
//    - assemble linear system,
//    - solve it with INMOST inner linear solver,
//    - save solution in a .vtk file.

// Workflow for Model class:
// 1. Prepare entries


using namespace INMOST;
using namespace std;

enum{
    T_ASSEMBLE = 0,
    T_SOLVE,
    T_PRECOND,
    T_IO,
    T_INIT,
    T_UPDATE
};

const string tagNameTensorK  = "HYDRAULIC_CONDUCTIVITY";
const string tagNameTensorD  = "DIFFUSION_TENSOR";
const string tagNameBCFlow   = "BC_FLOW";
const string tagNameBCTran   = "BC_TRANSPORT";
const string tagNameHead     = "Water_Head";
const string tagNameConc     = "Conc";
const string tagNameHeadPrev = "Water_Head_Prev";
const string tagNameConcPrev = "Conc_Prev";
const string tagNameWatFlux  = "Water_Flux";

const double dt              = 1e-3;
const int    nt              = 25;
const double volConcExp      = 1e3;
const double phi             = 0.4;
const double sstor           = 1e-6;
const double rho0            = 1e3;
const double D               = 1e-4;
variable density(variable C)
{
    return rho0 + volConcExp * C;
}

class Problem;
class Process;
class Process_ConfinedFlow;
class Process_Advection;
class Process_Diffusion;
class FV_Diffusion;
class FV_Diffusion_TPFA;

// =====================================================

class FV_Diffusion
{
protected:
    Mesh *m;
    Tag tagD;  // Diffusion tensor tag
    Tag tagBC; // Boundary condition
public:
    FV_Diffusion(Mesh *mm, string nameD, string nameBC)
    {
        if(mm == nullptr){
            cout << "Bad mesh pointer" << endl;
            exit(1);
        }
        m = mm;
        if(m->HaveTag(nameD)){
            tagD = m->GetTag(nameD);
        }
        else{
            cout << "Bad tensor name tag" << endl;
            exit(1);
        }
        if(m->HaveTag(nameBC)){
            tagBC = m->GetTag(nameBC);
        }
        else{
            cout << "Bad BC name tag" << endl;
            exit(1);
        }
    }
    virtual ~FV_Diffusion(){}
    virtual void build() = 0;
    virtual variable getDgradU(const Face &f, dynamic_variable &U) = 0;
    virtual double   getDgradZ(const Face &f) = 0;
};


class FV_Diffusion_TPFA : public FV_Diffusion
{
protected:
    Tag tagT; // TPFA transmissibility coeff
public:
    void build();
    variable getDgradU(const Face &f, dynamic_variable &U);
    double   getDgradZ(const Face &f);
    FV_Diffusion_TPFA(Mesh *mm, string s1, string s2) : FV_Diffusion(mm,s1,s2) {}
    ~FV_Diffusion_TPFA() {}
};

void FV_Diffusion_TPFA::build()
{
    tagT = m->CreateTag("TPFA_trans", DATA_REAL, FACE, NONE, 1);
    for(auto iface = m->BeginFace(); iface != m->EndFace(); iface++){
        Face f = iface->getAsFace();
        double xf[2];
        f.Barycenter(xf);

        if(f.Boundary()){            // Here 'p' and 'm' refer to '+' and '-'
            Cell cp = f.BackCell();
            double xp[2];
            cp.Barycenter(xp);

            rMatrix Dp(2,2), ne(2,1), lp(2,1);
            // initialize diffusion tensors
            Dp(0,0) = cp.RealArray(tagD)[0];
            Dp(0,1) = cp.RealArray(tagD)[2];
            Dp(1,0) = cp.RealArray(tagD)[2];
            Dp(1,1) = cp.RealArray(tagD)[1];

            // Get unit normal for face
            f.UnitNormal(ne.data());

            // Compute l's
            lp(0,0) = xf[0] - xp[0];
            lp(1,0) = xf[1] - xp[1];
            lp /= (xf[0] - xp[0])*(xf[0] - xp[0]) + (xf[1] - xp[1])*(xf[1] - xp[1]);

            double coef = (Dp*lp).DotProduct(ne);
            f.Real(tagT) = coef;
        }
        else{ // internal face
            // Here 'p' and 'm' refer to '+' and '-'
            Cell cp = f.BackCell(), cm = f.FrontCell();
            double xp[2], xm[2];
            cp.Barycenter(xp);
            cm.Barycenter(xm);

            rMatrix Dp(2,2), Dm(2,2), ne(2,1), lp(2,1), lm(2,1);
            // initialize diffusion tensors
            Dp(0,0) = cp.RealArray(tagD)[0];
            Dp(0,1) = cp.RealArray(tagD)[2];
            Dp(1,0) = cp.RealArray(tagD)[2];
            Dp(1,1) = cp.RealArray(tagD)[1];
            Dm(0,0) = cm.RealArray(tagD)[0];
            Dm(0,1) = cm.RealArray(tagD)[2];
            Dm(1,0) = cm.RealArray(tagD)[2];
            Dm(1,1) = cm.RealArray(tagD)[1];

            // Get unit normal for face
            f.UnitNormal(ne.data());

            // Compute l's
            lp(0,0) = xf[0] - xp[0];
            lp(1,0) = xf[1] - xp[1];
            lp /= (xf[0] - xp[0])*(xf[0] - xp[0]) + (xf[1] - xp[1])*(xf[1] - xp[1]);
            lm(0,0) = xf[0] - xm[0];
            lm(1,0) = xf[1] - xm[1];
            lm /= (xf[0] - xm[0])*(xf[0] - xm[0]) + (xf[1] - xm[1])*(xf[1] - xm[1]);

            double coef = (Dp*lp).DotProduct(ne) * (Dm*lm).DotProduct(ne);
            coef /= ((Dp*lp).DotProduct(ne) - (Dm*lm).DotProduct(ne));
            f.Real(tagT) = -coef;
            //printf("face %d: T = %e\n", f.LocalID(), coef);
        }
    }
}

variable FV_Diffusion_TPFA::getDgradU(const Face &f, dynamic_variable &U)
{
    variable res;
    if(f.Boundary()){
        // Check if Neumann, then flux is known
        if(f.RealArray(tagBC)[0] > 0.)
            return -f.RealArray(tagBC)[1]; // minus because we know flux whihj is -DgradU

        // Dirichlet
        Cell cp = f.BackCell();
        res = f.Real(tagT) * (f.RealArray(tagBC)[1] - U(cp));
        //cout << "Dir face" << endl;
    }
    else{
        Cell cp = f.BackCell(), cm = f.FrontCell();
        res = f.Real(tagT) * (U(cm) - U(cp));
    }
    return res;
}

double FV_Diffusion_TPFA::getDgradZ(const Face &f)
{
    double res;
    if(f.Boundary()){
        Cell cp = f.BackCell();
        double xf[2], xp[2];
        f.Barycenter(xf);
        cp.Barycenter(xp);
        res = f.Real(tagT) * (xf[1] - xp[1]);
    }
    else{
        Cell cp = f.BackCell(), cm = f.FrontCell();
        double xm[2], xp[2];
        cm.Barycenter(xm);
        cp.Barycenter(xp);
        res = f.Real(tagT) * (xm[1] - xp[1]);
    }
    return res;
}

// =====================================================

class Process
{
protected:
    Mesh *m;
    bool steady;
public:
    Process(Mesh *mm, vector<dynamic_variable> &dvars){ m = mm; }
    virtual ~Process(){}
    virtual void fillResidual(Residual &R) = 0;
    void setSteady(bool b) { steady = b; }
};

class Process_ConfinedFlow : public Process
{
private:
    FV_Diffusion_TPFA tpfa;
    dynamic_variable varH, varC;
    Tag oldH, oldC;
public:
    Process_ConfinedFlow(Mesh *mm, vector<dynamic_variable> &dvars);
    ~Process_ConfinedFlow(){}
    void fillResidual(Residual &R);
    variable getFlux(const Face &f);
};

Process_ConfinedFlow::Process_ConfinedFlow(Mesh *mm, vector<dynamic_variable> &dvars)
    : Process(mm, dvars), tpfa(mm, tagNameTensorK, tagNameBCFlow)
{
    tpfa.build();
    varH = dvars[0];
    varC = dvars[1];
    oldH = m->GetTag(tagNameHeadPrev);
    oldC = m->GetTag(tagNameConcPrev);
}

void Process_ConfinedFlow::fillResidual(Residual &R)
{
    for(auto iface = m->BeginFace(); iface != m->EndFace(); iface++){
        Face f = iface->getAsFace();
        Cell cp = f.BackCell(), cm = f.FrontCell();
        variable q = -1. * tpfa.getDgradU(f, varH);

        variable dens;
        if(cm.isValid())// && false)
            dens = 0.5 * (density(varC(cp) + density(varC(cm))));
        else
            dens = density(varC(cp));

        q += (dens - rho0)/rho0 * tpfa.getDgradZ(f);

        q *= dens;

        R[varH.Index(cp)] -= q;
        if(cm.isValid())
            R[varH.Index(cm)] += q;
    }
    for(auto icell = m->BeginCell(); icell != m->EndCell(); icell++){
        Cell cell = icell->getAsCell();
        if(!steady){
            variable val = (varH(cell) - cell.Real(oldH))/dt * cell.Volume();
            val *= sstor;
            val *= density(varC(cell));
            R[varH.Index(cell)] -= val;
        }

        R[varH.Index(cell)] -= phi * volConcExp * (varC(cell) - cell.Real(oldC)) / dt * cell.Volume();
    }
//    if(!steady)
//        cout << "Adding dH/dt" << endl;
}

variable Process_ConfinedFlow::getFlux(const Face &f)
{
    return -1. * tpfa.getDgradU(f, varH);
//    rMatrix U(1,2), ne(2,1);
//    U(0,0) = 100;
//    U(0,1) = 200;
//    f.UnitNormal(ne.data());
//    return U.DotProduct(ne);
}

// =====================================================

class Process_Advection : public Process
{
private:
    dynamic_variable varC;
    Tag oldC;
    Tag waterFlux;
    Process_ConfinedFlow *flow;
public:
    Process_Advection(Mesh *, vector<dynamic_variable> &);
    ~Process_Advection(){}
    void fillResidual(Residual &R);
    void setFlow(Process_ConfinedFlow *p) { flow = p; }
};

Process_Advection::Process_Advection(Mesh *mm, vector<dynamic_variable> &dvars)
    : Process(mm, dvars)
{
    varC = dvars[0];
    steady = true;
    oldC = m->GetTag(tagNameConcPrev);
}

void Process_Advection::fillResidual(Residual &R)
{
    for(auto icell = m->BeginCell(); icell != m->EndCell(); icell++){
        Cell cell = icell->getAsCell();
        if(!steady){
            double V = cell.Volume();
            R[varC.Index(cell)] -= (varC(cell) - cell.Real(oldC))/dt * V;
        }

        auto faces = cell.getFaces();
        for(auto iface = faces.begin(); iface != faces.end(); iface++){
            Face f = iface->getAsFace();
            variable flux = flow->getFlux(f);
            Cell cp = f.BackCell(), cm = f.FrontCell();
            if(cm.isValid()){
                if(flux.GetValue() > 0.)
                    flux *= varC(cp);
                else
                    flux *= varC(cm);
                if(cell == cm)
                    flux *= -1;
//                if(cell == cm){
//                    if(flux.GetValue() > 0.)
//                        flux *= -varC(cm);
//                    else
//                        flux *= -varC(cp);
//                }
//                else{
//                    if(flux.GetValue() > 0.)
//                        flux *= varC(cp);
//                    else
//                        flux *= varC(cm);
//                }
            }
            else
                flux *= varC(cp);
            R[varC.Index(cell)] -= flux;
        }
    }
//    if(!steady)
//        cout << "Adding dC/dt" << endl;
}

// =====================================================

class Process_Diffusion : public Process
{
private:
    FV_Diffusion_TPFA tpfa;
    dynamic_variable varC;
    Tag oldС;
public:
    Process_Diffusion(Mesh *mm, vector<dynamic_variable> &dvars);
    ~Process_Diffusion(){}
    void fillResidual(Residual &R);
};

Process_Diffusion::Process_Diffusion(Mesh *mm, vector<dynamic_variable> &dvars)
    : Process(mm, dvars), tpfa(mm, tagNameTensorD, tagNameBCTran)
{
    tpfa.build();
    varC = dvars[0];
    steady = true;
    oldС = m->GetTag(tagNameConcPrev);
}

void Process_Diffusion::fillResidual(Residual &R)
{
//    for(auto iface = m->BeginFace(); iface != m->EndFace(); iface++){
//        Face f = iface->getAsFace();
//        Cell cp = f.BackCell(), cm = f.FrontCell();
//        variable q = -1. * tpfa.getDgradU(f, varC);

//        R[varC.Index(cp)] -= q;
//        if(cm.isValid())
//            R[varC.Index(cm)] += q;
//    }
    for(auto icell = m->BeginCell(); icell != m->EndCell(); icell++){
        Cell cell = icell->getAsCell();
        if(!steady){
            double V = cell.Volume();
            R[varC.Index(cell)] -= (varC(cell) - cell.Real(oldС))/dt * V;
        }

        auto faces = cell.getFaces();
        for(auto iface = faces.begin(); iface != faces.end(); iface++){
            variable flux = -1. * tpfa.getDgradU(iface->getAsFace(), varC);
            if(cell == iface->FrontCell())
                flux *= -1.;
            R[varC.Index(cell)] -= flux;
        }
    }
//    if(!steady)
//        cout << "Adding dC/dt" << endl;
}

// =====================================================

// =====================================================

class Problem
{
private:
    Mesh m;
    Automatizator aut;

    Tag tagK; // Hydraulic conductivity tensor
    Tag tagD; // Diffusion tensor
    Tag tagBCFlow;
    Tag tagBCTran;
    Tag tagHead;
    Tag tagConc;
    Tag tagHeadPrev;
    Tag tagConcPrev;
    Tag tagWatFlux;

    double times[10];
    double ttt; // global timer

public:
    Problem(string meshName);
    ~Problem();
    void initProblem(); // create tags and set parameters
    void assembleGlobalSystem(); // assemble global linear system
    void assembleLocalSystem(Cell &, rMatrix &, rMatrix &);
    void solveSystem();
    void testDiffusion();
    void runSimulationFIM();
    void runSimulationSIM();
    void saveSolution(string path); // save mesh with solution
};

Problem::Problem(string meshName)
{
    ttt = Timer();
    for(int i = 0; i < 10; i++)
        times[i] = 0.;

    double t = Timer();
    m.Load(meshName);
    cout << "Number of cells: " << m.NumberOfCells() << endl;
//    cout << "Number of faces: " << m.NumberOfFaces() << endl;
//    cout << "Number of edges: " << m.NumberOfEdges() << endl;
//    cout << "Number of nodes: " << m.NumberOfNodes() << endl;
    m.AssignGlobalID(CELL|FACE|NODE);
    times[T_IO] += Timer() - t;
}

Problem::~Problem()
{
    printf("\n+=========================\n");
    printf("| T_assemble = %lf\n", times[T_ASSEMBLE]);
    printf("| T_precond  = %lf\n", times[T_PRECOND]);
    printf("| T_solve    = %lf\n", times[T_SOLVE]);
    printf("| T_IO       = %lf\n", times[T_IO]);
    printf("| T_update   = %lf\n", times[T_UPDATE]);
    printf("| T_init     = %lf\n", times[T_INIT]);
    printf("+-------------------------\n");
    printf("| T_total    = %lf\n", Timer() - ttt);
    printf("+=========================\n");
}

void Problem::initProblem()
{
    double t = Timer();

    tagHead = m.CreateTag(tagNameHead, DATA_REAL, CELL, NONE, 1);
    tagConc = m.CreateTag(tagNameConc, DATA_REAL, CELL, NONE, 1);
    tagHeadPrev = m.CreateTag(tagNameHeadPrev, DATA_REAL, CELL, NONE, 1);
    tagConcPrev = m.CreateTag(tagNameConcPrev, DATA_REAL, CELL, NONE, 1);
    tagWatFlux  = m.CreateTag(tagNameWatFlux, DATA_VARIABLE, FACE, NONE, 2);

    // Create scalar tensor tag
    tagK = m.CreateTag(tagNameTensorK, DATA_REAL, CELL, NONE, 3);
    tagD = m.CreateTag(tagNameTensorD, DATA_REAL, CELL, NONE, 3);
    for(auto icell = m.BeginCell(); icell != m.EndCell(); icell++){
        icell->RealArray(tagK)[0] = 1.0;
        icell->RealArray(tagK)[1] = 1.0;
        icell->RealArray(tagK)[2] = 0.0;
        icell->RealArray(tagD)[0] = D;
        icell->RealArray(tagD)[1] = D;
        icell->RealArray(tagD)[2] = 0.0;
    }

    // Create BC tag
    // BC go in form [type, val], where type = -1 (Dir) or 1 (Neum)
    tagBCFlow = m.CreateTag(tagNameBCFlow, DATA_REAL, FACE, FACE, 2);
    tagBCTran = m.CreateTag(tagNameBCTran, DATA_REAL, FACE, FACE, 2);
    for(auto iface = m.BeginFace(); iface != m.EndFace(); iface++){
        Face f = iface->getAsFace();
        if(!f.Boundary())
            continue;

        f.RealArray(tagBCFlow)[0] = 1.;
        f.RealArray(tagBCFlow)[1] = 0.;
        f.RealArray(tagBCTran)[0] = 1.;
        f.RealArray(tagBCTran)[1] = 0.;

        double x[2];
        f.Barycenter(x);
        if(x[1] < 1e-9){
            f.RealArray(tagBCFlow)[0] = -1.;
            f.RealArray(tagBCFlow)[1] =  0.;
        }
    }

    times[T_INIT] += Timer() - t;
    m.Save("init.vtk");
}

void Problem::assembleGlobalSystem()
{
    double t = Timer();
    times[T_ASSEMBLE] += Timer() - t;
}

void Problem::solveSystem()
{
    double t = Timer();
    times[T_UPDATE] += Timer() - t;
}

void Problem::saveSolution(string path)
{
    double t = Timer();
    m.Save(path);
    times[T_IO] += Timer() - t;
}

void Problem::runSimulationFIM()
{
    int linit = 0;

    double t = Timer();

    Automatizator::MakeCurrent(&aut);
    auto indH = aut.RegisterTag(tagHead, CELL);
    auto indC = aut.RegisterTag(tagConc, CELL);
    dynamic_variable varH(aut, indH);
    dynamic_variable varC(aut, indC);
    aut.EnumerateEntries();
    Residual R("R", aut.GetFirstIndex(), aut.GetLastIndex());

    vector<dynamic_variable> varsFlow, varsTran;
    varsFlow.push_back(varH);
    varsFlow.push_back(varC);
    varsTran.push_back(varC);
    Process_ConfinedFlow pFlow(&m, varsFlow);
    Process_Diffusion    pDiff(&m, varsTran);
    Process_Advection    pAdv (&m, varsTran);
    pFlow.setSteady(false);
    pDiff.setSteady(true);
    pAdv.setSteady(false);
    pAdv.setFlow(&pFlow);

    Solver S("inner_ilu2");
    S.SetParameter("relative_tolerance", "1e-12");
    S.SetParameter("absolute_tolerance", "1e-15");
    Sparse::Vector sol("sol", aut.GetFirstIndex(), aut.GetLastIndex());

    Tag tagDens = m.CreateTag("Density", DATA_REAL, CELL, NONE, 1);

    for(auto icell = m.BeginCell(); icell != m.EndCell(); icell++){
        Cell c = icell->getAsCell();
        double x[2];
        c.Barycenter(x);
        double r2 = (x[0]-0.5)*(x[0]-0.5) + (x[1]-0.5)*(x[1]-0.5);
        if(r2 < 0.01){
            c.Real(tagHead) = 0.;
            c.Real(tagConc) = 1.;
        }
        else{
            c.Real(tagHead) = 0.;
            c.Real(tagConc) = 0.;
        }
        c.Real(tagHeadPrev) = c.Real(tagHead);
        c.Real(tagConcPrev) = c.Real(tagConc);
        c.Real(tagDens)     = density(c.Real(tagConc)).GetValue();
    }
    times[T_INIT] += Timer() - t;

    t = Timer();
    m.Save("sol0.vtk");
    times[T_IO] += Timer() - t;

    int newtit = 0;
    for(int it = 0; it < nt; it++){
        cout << endl << "===== TIME STEP " << it << ", T = " << it*dt << " =====" << endl;
        // Save old values
        for(auto icell = m.BeginCell(); icell != m.EndCell(); icell++){
            Cell c = icell->getAsCell();
            c.Real(tagHeadPrev) = c.Real(tagHead);
            c.Real(tagConcPrev) = c.Real(tagConc);
        }

        // Newton loop
        bool converged = false;
        double norm2, norm2_0 = 0.0;
        for(int nit = 0; nit < 100; nit++){
            // Assemble residual
            t = Timer();
            R.Clear();
            pFlow.fillResidual(R);
            pDiff.fillResidual(R);
            pAdv.fillResidual(R);
            times[T_ASSEMBLE] += Timer() - t;

            norm2 = R.Norm();
            if(nit == 0)
                norm2_0 = norm2;
            cout << "it " << nit << ": |r|_2 = " << norm2 << endl;

            if(norm2 < 1e-6 || norm2 < 1e-5*norm2_0){
                converged = true;
                break;
            }

            t = Timer();
            S.SetMatrix(R.GetJacobian());
            newtit++;
            times[T_PRECOND] += Timer() - t;
            //R.GetJacobian().Save("J" + to_string(it+1) + ".mtx");
            t = Timer();
            bool solved = S.Solve(R.GetResidual(), sol);
            times[T_SOLVE] += Timer() - t;
            if(!solved){
                cout << "Linear solver failed: " << S.GetReason() << endl;
                cout << "Residual: " << S.Residual() << endl;
                exit(1);
            }
            //cout << "Linear solver iterations: " << S.Iterations() << endl;
            linit += S.Iterations();

            double w = 1;//0.125;
            for(auto icell = m.BeginCell(); icell != m.EndCell(); icell++){
                Cell c = icell->getAsCell();
                c.Real(tagHead) -= w*sol[varH.Index(c)];
                c.Real(tagConc) -= w*sol[varC.Index(c)];
                c.Real(tagDens)  = density(c.Real(tagConc)).GetValue();
            }
        }
        if(!converged){
            cout << "Newton failed" << endl;
            exit(1);
        }

        string name = "sol" + to_string(it+1) + ".vtk";
        t = Timer();
        m.Save(name);
        times[T_IO] += Timer() - t;
    }
    //cout << "Total Newton iterations: " << newtit << endl;
    //cout << "Total linear iterations: " << linit << endl;
    printf("Total Newton    iterations: %d (av. %d per t.st.)\n", newtit, newtit/nt);
    printf("Total linear    iterations: %d (av. %d per Newt.it.)\n", linit, linit/newtit);
}

void Problem::runSimulationSIM()
{
    int linit = 0;

    double t = Timer();

    Automatizator::MakeCurrent(&aut);
    auto indH = aut.RegisterTag(tagHead, CELL);
    auto indC = aut.RegisterTag(tagConc, CELL);
    dynamic_variable varH(aut, indH);
    dynamic_variable varC(aut, indC);
    aut.DeactivateEntry(indC);
    aut.EnumerateEntries();
    printf("Indices: %d %d\n", aut.GetFirstIndex(), aut.GetLastIndex());
    Residual RFlow("RFlow", aut.GetFirstIndex(), aut.GetLastIndex());

    aut.ActivateEntry(indC);
    aut.DeactivateEntry(indH);
    aut.EnumerateEntries();
    Residual RTran("RTran", aut.GetFirstIndex(), aut.GetLastIndex());


    vector<dynamic_variable> varsFlow, varsTran;
    varsFlow.push_back(varH);
    varsFlow.push_back(varC);
    varsTran.push_back(varC);
    Process_ConfinedFlow pFlow(&m, varsFlow);
    Process_Diffusion    pDiff(&m, varsTran);
    Process_Advection    pAdv (&m, varsTran);
    pFlow.setSteady(false);
    pDiff.setSteady(true);
    pAdv.setSteady(false);
    pAdv.setFlow(&pFlow);

    Solver S("inner_ilu2");
    S.SetParameter("relative_tolerance", "1e-12");
    S.SetParameter("absolute_tolerance", "1e-15");
    Sparse::Vector sol("sol", aut.GetFirstIndex(), aut.GetLastIndex());

    Tag tagDens = m.CreateTag("Density", DATA_REAL, CELL, NONE, 1);

    for(auto icell = m.BeginCell(); icell != m.EndCell(); icell++){
        Cell c = icell->getAsCell();
        double x[2];
        c.Barycenter(x);
        double r2 = (x[0]-0.5)*(x[0]-0.5) + (x[1]-0.5)*(x[1]-0.5);
        if(r2 < 0.01){
            c.Real(tagHead) = 0.;
            c.Real(tagConc) = 1.;
        }
        else{
            c.Real(tagHead) = 0.;
            c.Real(tagConc) = 0.;
        }
        c.Real(tagHeadPrev) = c.Real(tagHead);
        c.Real(tagConcPrev) = c.Real(tagConc);
        c.Real(tagDens)     = density(c.Real(tagConc)).GetValue();
    }
    times[T_INIT] += Timer() - t;

    t = Timer();
    m.Save("sol0.vtk");
    times[T_IO] += Timer() - t;

    int newtit = 0, nspl = 0;
    const double tol_split = 1e-4;
    for(int it = 0; it < nt; it++){
        cout << endl << "===== TIME STEP " << it << ", T = " << it*dt << " =====" << endl;
        // Save old values
        for(auto icell = m.BeginCell(); icell != m.EndCell(); icell++){
            Cell c = icell->getAsCell();
            c.Real(tagHeadPrev) = c.Real(tagHead);
            c.Real(tagConcPrev) = c.Real(tagConc);
        }

        bool converged_outer = false;
        bool smallNormF, smallNormT;
        smallNormF = smallNormT = false;
        for(int ispl = 0; ispl < 200; ispl++){
            nspl++;
            cout << endl << "*** splitting step " << ispl << " ***" << endl;
            // Newton loop for flow
            cout << "flow:" << endl;
            aut.ActivateEntry(indH);
            aut.DeactivateEntry(indC);
            aut.EnumerateEntries();
            bool converged = false;
            double norm2, norm2_0 = 0.0;
            for(int nit = 0; nit < 100; nit++){
                // Assemble residual
                t = Timer();
                RFlow.Clear();
                pFlow.fillResidual(RFlow);
                times[T_ASSEMBLE] += Timer() - t;

                norm2 = RFlow.Norm();
                if(nit == 0){
                    norm2_0 = norm2;
                    if(norm2_0 < tol_split)
                        smallNormF = true;
                }
                cout << " it " << nit << ": |r|_2 = " << norm2 << endl;

                if(norm2 < 1e-6 || norm2 < 1e-4*norm2_0){
                    converged = true;
                    break;
                }

                t = Timer();
                S.SetMatrix(RFlow.GetJacobian());
                newtit++;
                times[T_PRECOND] += Timer() - t;
                //R.GetJacobian().Save("J" + to_string(it+1) + ".mtx");
                t = Timer();
                bool solved = S.Solve(RFlow.GetResidual(), sol);
                times[T_SOLVE] += Timer() - t;
                if(!solved){
                    cout << "Linear solver failed: " << S.GetReason() << endl;
                    cout << "Residual: " << S.Residual() << endl;
                    exit(1);
                }
                //cout << "Linear solver iterations: " << S.Iterations() << endl;
                linit += S.Iterations();

                double w = 1;//0.125;
                for(auto icell = m.BeginCell(); icell != m.EndCell(); icell++){
                    Cell c = icell->getAsCell();
                    c.Real(tagHead) -= w*sol[varH.Index(c)];
                }
            }
            if(!converged){
                cout << "Newton for flow failed" << endl;
                exit(1);
            }


            // Newton loop for transport
            cout << "transport:" << endl;
            converged = false;
            norm2 = norm2_0 = 0.0;
            aut.DeactivateEntry(indH);
            aut.ActivateEntry(indC);
            aut.EnumerateEntries();
            for(int nit = 0; nit < 100; nit++){
                // Assemble residual
                t = Timer();
                RTran.Clear();
                pDiff.fillResidual(RTran);
                pAdv.fillResidual(RTran);
                times[T_ASSEMBLE] += Timer() - t;

                norm2 = RTran.Norm();
                if(nit == 0){
                    norm2_0 = norm2;
                    if(norm2_0 < tol_split)
                        smallNormT = true;
                }
                cout << " it " << nit << ": |r|_2 = " << norm2 << endl;

                if(norm2 < 1e-6 || norm2 < 1e-4*norm2_0){
                    converged = true;
                    break;
                }

                t = Timer();
                S.SetMatrix(RTran.GetJacobian());
                newtit++;
                times[T_PRECOND] += Timer() - t;
                //R.GetJacobian().Save("J" + to_string(it+1) + ".mtx");
                t = Timer();
                bool solved = S.Solve(RTran.GetResidual(), sol);
                times[T_SOLVE] += Timer() - t;
                if(!solved){
                    cout << "Linear solver failed: " << S.GetReason() << endl;
                    cout << "Residual: " << S.Residual() << endl;
                    exit(1);
                }
                //cout << "Linear solver iterations: " << S.Iterations() << endl;
                linit += S.Iterations();

                double w = 1;//0.125;
                for(auto icell = m.BeginCell(); icell != m.EndCell(); icell++){
                    Cell c = icell->getAsCell();
                    c.Real(tagConc) -= w*sol[varC.Index(c)];
                    c.Real(tagDens)  = density(c.Real(tagConc)).GetValue();
                }
            }
            if(!converged){
                cout << "Newton for transport failed" << endl;
                exit(1);
            }


            if(smallNormF && smallNormT){
                converged_outer = true;
                break;
            }
        }
        if(!converged_outer){
            cout << "splitting failed!" << endl;
            exit(1);
        }

        string name = "sol" + to_string(it+1) + ".vtk";
        t = Timer();
        m.Save(name);
        times[T_IO] += Timer() - t;
    }
//    cout << "Total Newton iterations: " << newtit << endl;
//    cout << "Total linear iterations: " << linit << endl;
    printf("Total splitting iterations: %d (av. %d per t.st.)\n", nspl, nspl/nt);
    printf("Total Newton    iterations: %d (av. %d per t.st., %d per spl.it.)\n", newtit, newtit/nt, newtit/nspl);
    printf("Total linear    iterations: %d (av. %d per Newt.it.)\n", linit, linit/newtit);
}


void Problem::testDiffusion()
{
    for(auto iface = m.BeginFace(); iface != m.EndFace(); iface++){
        Face f = iface->getAsFace();
        if(!f.Boundary())
            continue;

        double x[2];
        f.Barycenter(x);
        if(fabs(x[0]) < 1e-10){
            // Dir BC 1
            f.RealArray(tagBCTran)[0] = -1;
            f.RealArray(tagBCTran)[1] = 0.;
        }
        else if(fabs(x[0] - 1.) < 1e-10){
            // Dir BC 2
            f.RealArray(tagBCTran)[0] = -1;
            f.RealArray(tagBCTran)[1] = 1.;
        }
        else{
            // Neum BC 0
            f.RealArray(tagBCTran)[0] = 1.;
            f.RealArray(tagBCTran)[1] = 0.;
        }
    }

    Automatizator::MakeCurrent(&aut);
    auto indC = aut.RegisterTag(tagConc, CELL);
    dynamic_variable varC(aut, indC);
    aut.EnumerateEntries();
    Residual R("R", aut.GetFirstIndex(), aut.GetLastIndex());

    //    Process_ConfinedFlow pFlow;
    //    Process_Advection pAdv;
    vector<dynamic_variable> varsTran;
    varsTran.push_back(varC);
    Process_Diffusion pDiff(&m, varsTran);

    pDiff.fillResidual(R);

    Sparse::Vector sol("sol",aut.GetFirstIndex(), aut.GetLastIndex());
    Solver S("inner_ilu2");
    S.SetMatrix(R.GetJacobian());
    bool solved = S.Solve(R.GetResidual(), sol);
    if(!solved){
        cout << "Linear solver failed: " << S.GetReason() << endl;
        cout << "Residual: " << S.Residual() << endl;
        exit(1);
    }
    cout << "Linear solver iterations: " << S.Iterations() << endl;

    double normC = 0.0;
    Tag Err = m.CreateTag("Error", DATA_REAL, CELL, NONE, 1);
    for(auto icell = m.BeginCell(); icell != m.EndCell(); icell++){
        Cell c = icell->getAsCell();
        c.Real(tagConc) -= sol[varC.Index(c)];
        double x[2];
        c.Barycenter(x);
        c.Real(Err) = fabs(x[0]+0. - c.Real(tagConc));
        normC = max(normC, c.Real(Err));
    }
    cout << "|err|_C = " << normC << endl;
    m.Save("res.vtk");
}

int main(int argc, char *argv[])
{
    if(argc != 3){
        cout << "Usage: 2d_dens_driven_flow <mesh_file> <method (fim or sim)>" << endl;
        return 1;
    }
    string method(argv[2]);
    if(method != "fim" && method != "sim"){
        cout << "Usage: 2d_dens_driven_flow <mesh_file> <method (fim or sim)>" << endl;
        return 1;
    }

    Problem P(argv[1]);
    P.initProblem();
    //P.testDiffusion();
    if(method == "fim")
        P.runSimulationFIM();
    else if(method == "sim")
        P.runSimulationSIM();

    return 0;
}
