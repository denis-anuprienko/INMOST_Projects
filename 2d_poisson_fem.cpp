#include "inmost.h"

//    This code solves boundary value problem
//    for 2D Poisson equation in (0;1)x(0;1)
//    using P1 FEM.
//
//    The user should provide 2D mesh
//    (preferrably, a .vtk file which can be generated by Gmsh for example)
//    which is built for (0;1)x(0;1)
//
//    The code will then
//    - process mesh,
//    - init boundary condition and RHS tags,
//    - assemble linear system,
//    - solve it with INMOST inner linear solver,
//    - save solution in a .vtk file.


using namespace INMOST;
using namespace std;

const string tagNameTensor = "DIFFUSION_TENSOR";
const string tagNameBC = "BOUNDARY_CONDITION";
const string tagNameRHS = "RHS";

void setProblemParams(Mesh *m)
{
    // Set parameters for the following problem:
    //
    //       div(-D grad U) = f       in unit square
    //       a*U + b*(-D grad U) = c  on boundary
    //
    // - diffusion tensor,    3 numbers (Dxx, Dyy, Dxy)
    // - boundary conditions, 3 numbers (a,b,c)
    // - right-hand side,     1 number  (f)
    //
    // Currently, D = I and BCs and RHS correspond to solution u(x,y) = x+1

    Tag tagD   = m->CreateTag(tagNameTensor, DATA_REAL, CELL, NONE, 3);
    Tag tagBC  = m->CreateTag(tagNameBC,     DATA_REAL, FACE, FACE, 3);
    Tag tagRHS = m->CreateTag(tagNameRHS,    DATA_REAL, CELL, NONE, 1);

    for(auto icell = m->BeginCell(); icell != m->EndCell(); icell++){
        if(icell->GetStatus() == Element::Ghost)
            continue;
        icell->RealArray(tagD)[0] = 1.; // Dxx
        icell->RealArray(tagD)[1] = 1.; // Dyy
        icell->RealArray(tagD)[2] = 0.; // Dxy

        icell->Real(tagRHS) = 0.;
    }
    m->ExchangeData(tagD, CELL);

    for(auto iface = m->BeginFace(); iface != m->EndFace(); iface++){
        if(iface->GetStatus() == Element::Ghost || !iface->Boundary())
            continue;

        double x[3];
        iface->Barycenter(x);
        if(fabs(x[0] - 0.) < 1e-15){
            iface->RealArray(tagBC)[0] = 1.;
            iface->RealArray(tagBC)[1] = 0.;
            iface->RealArray(tagBC)[2] = 1.;
        }
        else if(fabs(x[0] - 1.) < 1e-15){
            iface->RealArray(tagBC)[0] = 1.;
            iface->RealArray(tagBC)[1] = 0.;
            iface->RealArray(tagBC)[2] = 2.;
        }
        else{
            iface->RealArray(tagBC)[0] = 0.;
            iface->RealArray(tagBC)[1] = 1.;
            iface->RealArray(tagBC)[2] = 0.;
        }
    }
}

int main(int argc, char *argv[])
{
    if(argc != 2){
        cout << "Usage: 2d_poisson_fem <mesh_file>" << endl;
        return 1;
    }

    Mesh mesh;
    mesh.Load(argv[1]);
    cout << "Number of cells: " << mesh.NumberOfCells() << endl;
    cout << "Number of faces: " << mesh.NumberOfFaces() << endl;
    cout << "Number of edges: " << mesh.NumberOfEdges() << endl;
    cout << "Number of nodes: " << mesh.NumberOfNodes() << endl;

    setProblemParams(&mesh);

    mesh.Save("res.vtk");

    return 0;
}
